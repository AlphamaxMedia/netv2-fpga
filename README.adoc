# NeTV2 LiteX Quickstart Guide


These instructions can be used to quickly start development.

*tl;dr:*

1. Check out this repo with `git clone --recurse-submodules https://github.com/xobs/netv2-fpga.git`.
1. Ensure you have Python 3.5 or newer installed.
1. Ensure you have `make` installed.
1. Download the Risc-V toolchain from https://www.sifive.com/products/tools/ and put it in your PATH.
1. Go to https://www.xilinx.com/support/download.html and download `All OS installer Single-File Download`
1. Do a minimal Xilinx install to /opt/Xilinx/, and untick everything except `Design Tools / Vivado Design Suite / Vivado` and `Devices / Production Devices / 7 Series`
1. Go to https://www.xilinx.com/member/forms/license-form.html, get a license, and place it in ~/.Xilinx/Xilinx.lic
1. Run `./build.py` (or `python3 ./build.py`)

## Updating

To update the repo to the upstream version, including all dependencies, run:

```sh
git pull
git submodule update --recursive
```

## Using build.py Environment

Unlike other build environments (such as Conda, virtualenv, pip, etc.), build.py
doesn't stash files outside of this directory.  It works by modifying the environment,
and providing its own `site.py` to prevent the systemwide Python from putting its
own packages ahead of `PYTHONPATH`.

To interact with the Python environment, you can use the `-e` option.  For example, to
run a Python interpreter under the environment, run:

```sh
$ ./build.py -e python3
```

This will give you a Python interpreter that runs in the same environment as the litex code.

You can also run bash under the same environment:

```sh
$ ./build.py -e bash
```

This can be handy for debugging issues with upstream libraries, or for figuring out
interdependencies that are otherwise difficult to suss out.

The `netv2mvp.py` module, which is run by default, supports several arguments.  If you want
to build for a different environment, you will need to use the `-e` argument.  For example,
to build for the xc7a100t-fgg484-2 instead of the default xc7a35t-fgg484-2, invoke
the command with -p:

```sh
$ ./build.py -e netv2mvp.py -p 100
```

(If the command ends in ".py", then it is assumed to be a Python script, and is run under
the same interpreter as `build.py`)

## Working with Dependencies

Dependencies are managed through `git`, and managing their usage is largely an exercise
in working with `git`.

For example, if you would like to make a change to `litex`, go into `deps/litex` and checkout
a new branch and create a new upstream repo.  If you're working on Github, you would do
something like fork the repo to your own organization.

As an example, assume `sutajiokousagi` has forked upstream `litex`:

```sh
$ cd deps/litex
$ git checkout -b new-feature
$ git remote add kosagi git@github.com:sutajiokousagi/litex.git
$ cd -
```

Then, make changes to `deps/litex` as needed.

When you want to merge changes upstream, go into `deps/litex/` and push the branch to your remote:

```sh
$ cd deps/litex
$ git push kosagi new-feature
$ cd -
```

Then you can go and open a Pull Request on Github.

## Fetching Updates

Dependencies are designed to be independent, and you should update them as needed.  To update a particular
dependency, go into that dependency's subdirectory and run `git pull`.  You may also find it easier to
pull updates from a particular dependency and merge them.  For example, if you're working on the `new-feature`
branch of `litex` and want to pull changes from upstream, run:

```sh
$ cd deps/litex
$ git fetch origin
$ git merge master
$ cd -
```

This will merge all changes from upstream onto your own branch.

## Rationale

NeTV2 uses Migen for its HDL, and uses many components from the LiteX project.
These are primarily written in Python, which has a large number of options
available for configuring installs, ranging from global installs, virutlalenv, conda,
as well as several others.  Everyone has an opinion on what's right.

These instructions ignore all of that, in favor of simplicity.  You likely already
have a copy of `make` and `python`, and you probably ought to have a compiler
installed for other projects.  It's also more challenging to work on submodules
when they're combined together in a `site-packages` repository.

This quickstart takes a different approach in that it doubles-down on using native
components and simply modifies several magical environment variables to make
it all work.  As a bonus, it works on platforms where Conda doesn't, such as
platforms where packages might not be available.

## Support programs

There is a wrapper script in this repo to run litex_server and litex_term as well.  These may be invoked either with python (`python bin/litex_server udp`) or on Unix-type systems they may be executed directly (`./bin/litex_server udp`).

## Xilinx PATH

If your Xilinx install is in the default path (`C:\\Xilinx` on Windows, `/opt/Xilinx` on Linux), then the build system should be able to automatically find Xilinx.

If not, you can add the `bin` directory to your PATH.

## PyCharm integration

PyCharm needs to know about the dependency structure in order to allow you to drill down into modules and auto-complete statements.

Open this directory in PyCharm and expand the `deps` directory.  Then hold down `Shift` and select all subdirectories under `deps/`.  For example, this will include `litedram`, `liteeth`, and so on.

Then, right-click and select `Mark directory as...` and select `Sources Root`.

When running your module from within PyCharm, you may find it useful to set environment variables.  You can use `build.py -p > pycharm.env` to create a `.env`-compatible file.  There are several PyCharm plugins that can make use of this file.

## Visual Studio Code integration

Visual Studio Code needs to know where modules are.  These are specified in environment variables, which are automatically read from a .env file in your project root.  Create this file to enable pylint and debugging in Visual Studio Code:

````sh
python build.py --print-env > .env
````